
/**
 * This structure is identitcal to a Binary Heap 
 * but the Heap order property for any node at an even depth,
 * the element that is stored is less than the parent but larger than the grandparent
 * and for any node at an odd depth
 * is larger than the parent but smaller than the grandparent
 * @author Adish
 *
 */
public class MinMaxHeap<Anytype extends Comparable <? super Anytype>> 
{
	/**
	 * private variables
	 */
	private int currentSize;
	private Anytype[] array;
	private static final int DEFAULT_CAPACITY = 10; // constant for the max size of a Heap
	public Node root;
	
	class Node
	{
		Anytype data;
		int level;
		Node right;
		Node left;
	}
	
	/**
	 * Default constructor
	 */
	public MinMaxHeap()
	{
		this (DEFAULT_CAPACITY);
	}
	
	
    /**
     * Construct the binary heap given an array of items.
     */
    public MinMaxHeap( Anytype [ ] items )
    {
            currentSize = items.length;
            array = (Anytype[]) new Comparable[ ( currentSize + 2 ) * 11 / 10 ];

            int i = 1;
            for( Anytype item : items )
                array[ i++ ] = item;
            buildHeap( );
    }
    
	/**
	 * Paramatized
	 * @param capacity
	 */
	public MinMaxHeap(int capacity)
	{
		
	}
	
	public MinMaxHeap(Anytype[] items)
	{
		currentSize = items.length;
		array = (Anytype[]) new Comparable[ ( currentSize + 2 ) * 11 / 10];
		
		int i = 1;
		for(Anytype item : items )
		{
			array[ i++ ] = item;
		}
		buildHeap();
	}
	
	
	public void insert(Anytype x)
	{
		if (currentSize == array.length - 1)
			enlargeArray(array.length * 2 + 1);
		
		// percolating upwards
		
		int hole = ++currentSize;	
		for(array[0] = x; x.compareTo( array[ hole / 2 ] ) < 0; hole /= 2)
		{
			array[hole] = array[hole / 2];
		}
		array[hole] = x;
	}
	
	private void enlargeArray(int i)
	{
		// TODO Auto-generated method stub
		
	}

	public Anytype deleteMin() throws Exception
	{
		if (isEmpty())
			throw new Exception();
		
		Anytype minItem = findMin();
		array[1] = array[currentSize--];
		return minItem;
	}
	
	private Anytype findMin()
	{
		return null;
	}
	
//	private Anytype findMax()
//	{
//		return null;
//	}

	public boolean isEmpty()
	{
		return false;
	}
	
	private void makeEmpty()
	{
		
	}
	
	private void percolateDown(int hole)
	{
		int child;
		Anytype temp = array[hole];
		
		for( ; hole * 2 <= currentSize; hole = child)
		{
			child = hole * 2;
			if (child != currentSize && array[child + 1].compareTo(array[child]) < 0)
					child++;
			if (array[child].compareTo(temp) < 0)
				array[hole] = array[child];
			else
				break;
		}
		array[hole] = temp;
	}
	
	private void buildHeap()
	{
		for (int i = currentSize / 2; i > 0; i--)
			percolateDown(i);
	}
	
	/**
	 * Need to edit later
	 * @param targetNode
	 * @return
	 */
	public int height(Node targetNode)
	{
		// check the target Node location
		if(targetNode == null)
			return 0;
		
		int leftHeight = height(targetNode.left);
		int rightHeight = height(targetNode.right);
		
		if(leftHeight >= rightHeight)
		{
			return leftHeight + 1;
		}
		return rightHeight + 1;
	}

	
}
